#+title: Finite state machines
#+startup: showall
#+options: toc:nil
#+latex_header: \newcommand{\sync}{\mathbin{\&}}
#+latex_header: \newcommand{\then}{\mathbin{;}}
#+latex_header: \newcommand{\e}{\varepsilon}
#+latex_header: \newcommand{\unit}{\mathbf{1}}
#+latex_header: \newcommand{\void}{\mathbf{0}}

Fix, once and for all, an infinite set, $\mathcal{S}$, of /symbols/.

A /history/ is a finite sequence, $(\alpha_1, \alpha_2, \dotsc, \alpha_N)$ of
symbols from $\mathcal{S}$. The empty history is written $\e$. The
/concatenation/ of two histories $h$ and $g$, written $hg$, consists of all the
symbols of $h$ followed by all the symbols of $g$. Clearly $\e f = f\e = f$ for
any history $f$.

A /behaviour/ is a set of histories. We denote the behaviour consisting of no
sequences by $\void$ and the beheaviour consisting only of the empty
sequence by $\unit$.

The intended interpretation of all this is that a history is a particular
computation of a state machine. A behaviour is the set of all possible
computations of that machine. How might we combine behaviours?

Let $M$ and $N$ be behaviours. By 
\begin{equation}
M\then N 
\end{equation}
(pronounced “$M$ then $N$”) we mean the behaviour whose histories consist of
all those that can be obtained as a sequence in $M$ concatenated with a sequence
in $N$. Note that the “semicolon operator” is associative, $M\then (N\then O) =
(M\then N)\then O$, but not, in general, commutative.

We have immediately that
#+begin_src latex
\begin{equation}
M\then\unit = \unit\then M = M
\end{equation}
#+end_src
and
#+begin_src latex
  \begin{equation}
  M\then\void = \void\then M = \void
  \end{equation}
#+end_src

for any behaviour $M$. 

As a special case, suppose $M$ is a behaviour and $\alpha$ is a symbol. Then 
$$
\alpha \to M
$$ is the behaviour consisting of all histories in $M$, prefixed
with the symbol $\alpha$.

Let $M$ and $N$ be behaviours as above. Then by
$$
M \sync N
$$
we mean the behaviour whose histories are those that occur in both $M$ and
$N$. The operator $\sync$ is associative and---unlike the semicolon
operator---commutative. We also have the identities:
$$
M\sync \void = \void\sync M = \void,
$$
and
$$
M \sync M = M.
$$

The distributive law only “works” in one direction:
$$
P\then (M\sync N) \subseteq (P\then M)\sync (P\then N) 
$$

This way is certainly true, because an element of the lhs is a history in $P$,
say $p$, followed by a history in both $M$ and $N$, say $q$, so the history $pq$
is certainly in both behaviours on the rhs.

Conversely, suppose $P = \{\e, \alpha\}$, $M = \{\alpha, \alpha\beta\}$, and $N
= \{\beta\}$. Then both $P\then M$ and $P\then N$ include the history
$\alpha\beta$ (coming from $\e\,\alpha\beta$ in the one case and $\alpha\,\beta$
in the other). But $M\sync N = \void$, so the lhs is empty. 

Note that insisting that behaviours were prefix-closed would not have helped us
here since the argument goes through with $P = \{\e, \alpha\}$, $M = \{\e, \alpha,
\alpha\beta\}$, and $N = \{\e, \beta\}$. In this case $M\sync N = \{\e\}$, which
still does not include $\alpha\beta$.





* Todo

** Prefix-closure

What if the behaviours are prefix-closed? 

- Does the distributive law now hold? (No.)
- Should we redefine $\sync$ to be “intersect the prefix”? 
- Are the operators strict (and do they preserve prefix-closure)?




