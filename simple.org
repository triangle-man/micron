#+title: The simplest progamming language ever
#+startup: showall
#+options: toc:nil
#+latex_header: \usepackage{ebproof}
#+latex_header: \DeclareMathOperator{\unit}{\text{\tt unit}}
#+latex_header: \DeclareMathOperator{\id}{\text{\tt id}}
#+latex_header: \DeclareMathOperator{\fst}{\text{\tt fst}}
#+latex_header: \DeclareMathOperator{\snd}{\text{\tt snd}}
#+latex_header: \DeclareMathOperator{\src}{source}
#+latex_header: \DeclareMathOperator{\trg}{target}
#+latex_header: \DeclareMathOperator{\typ}{type}

* Categories

TBD.

* Expressions

Here is what you might call a “programming language,” if you were being
charitable.

Fix, once and for all, a countable collection of /atomic types/, $A, B, C,
\dotsc$. A /type/ is either an atomic type, or $\top$, or $P\times Q$, where $P$
and $Q$ are types. (In code, we write ~P * Q~ for $P\times Q$.) An /arrow type/
is a pair of types, which we write separated by an arrow, such as $P\to
Q$. If $P\to Q$ is an arrow type, we call $P$ the /source/ and $Q$ the /target/.

A program is now “a thing with an arrow type.” The syntax of programs is defined
by terms and expressions. A /term/ is one of the following, where $e_1$ and
$e_2$ are arbitrary expressions (which will be defined in a minute):
\begin{equation*}
  t \equiv \unit 
  \mid \id 
  \mid \fst
  \mid \snd
  \mid \langle e_1, e_2 \rangle
  \mid e_2 \circ e_1.
\end{equation*}
The intended reading of the last rule, involving a juxtaposition of two
expressions, is the composition of two functions, the the second following the
first. (But note that there are no functions here.)

An /expression/ is defined by a term together with an arrow type, which we write
as, say, $t : P\to Q$. If $e = t : P\to Q$ is an expression, then
$\typ(e)\equiv P\to Q$. 

One more bit of notational convenience. If $e$ is an expression, then we also
write $e : P\to Q$ to mean “$e$ is an expression such that $\typ(e) = P\to
Q$. 

Not all combinations of terms and arrow types are expresssions; the following
defines which constructions are allowed:
\begin{equation*}
\begin{split}
  e \equiv &\unit : P \to \top \\
    &\mid \id : P \to P \\
    &\mid \fst : P \times Q \to P \\
    &\mid \snd : P \times Q \to Q \\
    &\mid \langle e_1 : P \to Q, e_2 : P \to R \rangle : P \to Q \times R \\
    &\mid (e_2 : Q \to R) \circ (e_1 : P \to Q) : P \to R.
\end{split}
\end{equation*}
You can see that the rules say how to line up the types to make sensible
combinations. For example, the rule for $\id$ says that “identities map a type
to itself.” (Not really, because terms aren't maps and types aren't sets; but
that's the sort of thing one is supposed to imagine.) As another example, the
rule for composition says that the target of $e_1$ has to be the source of $e_2$,
which is very sensible if you want to compose functions.

In the last two productions in the definition of expressions, we have used the
notational convenience introduced above. 

It is sometimes difficult to write out expressions because they rapidly become
very long. An alternative approach is to write the syntax tree of the expression
as an actual tree. Each node in the tree is an expression with the types erased,
except for the type of the whole expression; the children of that node
demonstrate that it is an allowed expression by exhibiting the types of its
constituents.

For example, consider the following expression
\begin{equation*}
\bigl(\fst : A \times \top \to A\bigr) \circ \bigl( \langle \id :A \to A, \unit : A \to \top \rangle : A \to A \times \top\bigr) : A \to A.
\end{equation*}
And now here is the same thing written in the tree notation. Note that parent
nodes are written below their child nodes; so we start at the top with the
innermost (atomic) expressions.
\begin{equation*}
  \begin{prooftree}
    \hypo{\fst : A \times \top \to A}
    \hypo{\id : A \to A}
    \hypo{\unit : A \to \top}
    \infer2{\langle \id, \unit\rangle : A \to A \times \top}
    \infer2{\fst \circ {\langle \id, \unit \rangle : A \to A}}
  \end{prooftree}
\end{equation*} 

The tree notation conveys the same information as the expression but is easier
to read. In particular, it is easier to check that the types are all of the
correct form for each way of construction an expression.

Well, now, it /almost/ looks like we have a category. The definition would go
something like this: let the objects be types, and let the morphisms be
expressions. A morphism $e:P\to Q$ is just an expression whose arrow type is
$P\to Q$. To compose morphisms, use the rule of composition.

However, we do not, thereby, obtain a category. One must check the category
axioms and these in general do not hold. For example, the only reasonable
candidate for an identity morphism is $\id$ but the expression $\id:A\to A$
is patently not the same expression as $(\id:A\to A)\circ(\id:A\to A)$.

A separate problem is that composition (of expressions) is not
associative. Consider the following expression (written in tree notation):
\begin{equation*}\footnotesize
  \begin{prooftree}
    \hypo{\snd : A \times B \to B}
    \hypo{\fst : (A \times B) \times C \to A \times B}
    \hypo{\fst : ((A \times B) \times C) \times D \to (A \times B) \times C}
    \infer2{\fst\circ\fst : ((A \times B) \times C) \times D \to A \times B}
    \infer2{\snd \circ (\fst\circ\fst) : ((A \times B) \times C) \times D \to B}
    \end{prooftree}.   
\end{equation*}
And here is another way of constructing the same expression:
\begin{equation*}\footnotesize
  \begin{prooftree}
    \hypo{\snd : A \times B \to B}
    \hypo{\fst : (A \times B) \times C \to A \times B}
    \infer2{\snd\circ\fst : (A \times B) \times C \to B}
    \hypo{\fst : ((A \times B) \times C) \times D \to (A \times B) \times C}
    \infer2{(\snd\circ\fst)\circ\fst : ((A \times B) \times C) \times D \to B}
    \end{prooftree}.   
\end{equation*}
On the face of it, these two are not the same construction, hence not the same
expression. 


** Reduction relations

We now introduce a reduction relation, $\Rightarrow$, on expressions, specifically
on expressions that have the form $e\circ f$. The cases break down by the form
of $e$.

First, the easy cases. In the following, $e$ and $f$ are any expressions.  We
have omitted the types in these relations because the whole expression after the
reduction necessarily has the same type as the expression before the
reduction. In the last reduction, this meanse that the type of $\unit$ has to
change. However, there's only one way it can changed to make the types compose
properly, so we have not bothered to write it in.
\begin{equation*}
\begin{split}
\id \circ e   &\Rightarrow e \\
e \circ \id    &\Rightarrow e \\
\unit \circ e &\Rightarrow \unit. 
\end{split}
\end{equation*}

Then there is the rule that says that pairing, followed by immediate projection
onto one element, can be replaced by that element:
\begin{equation*}
\begin{split}
\fst\circ \left\langle e, f\right\rangle &\Rightarrow e \\
\snd\circ \left\langle e, f\right\rangle &\Rightarrow f.
\end{split}
\end{equation*}

Then pairing “eats up” expression to its right:
\begin{equation*}
\left\langle e, f\right\rangle \circ g \Rightarrow 
\left\langle e\circ g, f\circ g\right\rangle. 
\end{equation*}

Finally, a rule that in the end sorts out associativity:
\begin{equation*}

\end{equation*}
 

It turns out that we can fix all these problems by introducing an equivalence
relation on well-typed programs. First, we simply don't indicate the order of
composition in terms. For example, we write ~snd fst fst~ rather than ~(snd fst)
fst~ or ~snd (fst fst)~.

Second, we introduce a reduction relation on terms, with the following two
rules:
\begin{equation*}
  t\; \text{\tt id} \Rightarrow t
  \quad\text{and}\quad
  \text{\tt id}\; t \Rightarrow t 
\end{equation*}
for any term $t$;
\begin{equation*}
  \text{\tt unit}\; t \Rightarrow \text{\tt unit}
\end{equation*}
for any term $t$; and 
\begin{equation*}
  \text{\tt fst}\;(t_1, t_2) \Rightarrow t_1 
  \qquad\text{and}\qquad
  \text{\tt snd}\;(t_1, t_2) \Rightarrow t_2 
\end{equation*}
for any terms $t_1$ and $t_2$. (Note that these relations on terms are all
arrow type--preserving and so are also reduction relations on expressions.) 


* OLD

We note that, if some expression has a well-typed program, then it is always
possible to deduce it. (A separate question, not addressed here, is whether one
can always assign an arrow type to a term to produce a well-typed program.)

To see this, consider an expression $e = t:P\to Q$, where $t$ is a term and $P$
and $Q$ are types. If $t$ is one of the “built-in” terms, ~fst~, ~snd~, ~id~, or
~unit~, then $P$ and $Q$ must have the appropriate forms for those types and we
are done. Otherwise, $t$ is either a product or a composition. If it is a
product, then we must have $t = (r, s)$ for some $r$ and $s$ and, in addition,
$Q = R\times S$ for some $R$ and $S$. We may therefore assign arrow types to $r$
and $s$ as $r : P\to R$ and $s : P\to S$. 

On the other hand, if $t$ is a composition, then by associativity, it must be of
the form 














 




* Footnotes

[fn:1] Jean-Yves Girard, /Proofs and Types/ (available from
http://paultaylor.eu/stable/prot.pdf).  
