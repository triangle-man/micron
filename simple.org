#+title: The simplest progamming language ever
#+startup: showall
#+options: toc:nil
#+latex_header: \usepackage{ebproof}
#+latex_header: \newcommand{\unit}{\text{\tt unit}}
#+latex_header: \newcommand{\id}{\text{\tt id}}
#+latex_header: \newcommand{\fst}{\text{\tt fst}}
#+latex_header: \newcommand{\snd}{\text{\tt snd}}
#+latex_header: \DeclareMathOperator{\src}{source}
#+latex_header: \DeclareMathOperator{\trg}{target}
#+latex_header: \DeclareMathOperator{\typ}{type}
#+latex_header: \newcommand{\termstep}{\Rightarrow}
#+latex_header: \newcommand{\step}{\Rightarrow^1}
#+latex_header: \newcommand{\steps}{\Rightarrow^*}

* Categories

TBD.

* Expressions

Here is what you might call a “programming language,” if you were being
charitable.

Fix, once and for all, a countable collection of /atomic types/, $A, B, C,
\dotsc$. A /type/ is either an atomic type, or $\top$, or $P\times Q$, where $P$
and $Q$ are types. (In code, we write ~P * Q~ for $P\times Q$.) An /arrow type/
is a pair of types, which we write separated by an arrow, such as $P\to
Q$. If $P\to Q$ is an arrow type, we call $P$ the /source/ and $Q$ the /target/.

A program is now “a thing with an arrow type.” The syntax of programs is defined
by terms and expressions. A /term/ is one of the following:
\begin{equation*}
\begin{split}
  t \equiv &\id : P \to P \\
  &\mid \fst : P \times Q \to P \\
  &\mid \snd : P \times Q \to Q \\
  &\mid \unit : P \to \top \\
\end{split}
\end{equation*}

An expression is either a term or a construction from other expressions. When
constructing expressions, it is necessary to follow certain rules regarding the
arrow types of the subexpressions and the arrow type of the constructed
expression. Specifically, an /expression/ is:
\begin{equation*}
\begin{split}
  e \equiv &\;t \\
    &\mid \langle e_1 : P \to Q, e_2 : P \to R \rangle : P \to Q \times R \\
    &\mid (e_2 : Q \to R) \circ (e_1 : P \to Q) : P \to R.
\end{split}
\end{equation*}
The intended reading of the last rule, involving a juxtaposition of two
expressions, is the composition of two functions, the the second following the
first. (But note that there are no functions here.)

You can see that the rules say how to line up the types to make sensible
combinations. For example, the rule for $\id$ says that “identities map a type
to itself.” (Not really, because terms aren't maps and types aren't sets; but
that's the sort of thing one is supposed to imagine.) As another example, the
rule for composition says that the target of $e_1$ has to be the source of $e_2$,
which is very sensible if you want to compose functions.

It is sometimes difficult to write out expressions because they rapidly become
very long. An alternative approach is to write the syntax tree of the expression
as an actual tree. Each node in the tree is an expression with the types erased,
except for the type of the whole expression; the children of that node
demonstrate that it is an allowed expression by exhibiting the types of its
constituents.

For example, consider the following expression
\begin{equation*}
\bigl(\fst : A \times \top \to A\bigr) \circ \bigl( \langle \id :A \to A, \unit : A \to \top \rangle : A \to A \times \top\bigr) : A \to A.
\end{equation*}
And now here is the same thing written in the tree notation. Note that parent
nodes are written below their child nodes; so we start at the top with the
innermost (atomic) expressions.
\begin{equation*}
  \begin{prooftree}
    \hypo{\fst : A \times \top \to A}
    \hypo{\id : A \to A}
    \hypo{\unit : A \to \top}
    \infer2{\langle \id, \unit\rangle : A \to A \times \top}
    \infer2{\fst \circ {\langle \id, \unit \rangle : A \to A}}
  \end{prooftree}
\end{equation*} 

The tree notation conveys the same information as the expression but is easier
to read. In particular, it is easier to check that the types are all of the
correct form for each way of construction an expression.

Well, now, it /almost/ looks like we have a category. The definition would go
something like this: let the objects be types, and let the morphisms be
expressions. A morphism $e:P\to Q$ is just an expression whose arrow type is
$P\to Q$. To compose morphisms, use the rule of composition.

However, we do not, thereby, obtain a category. One must check the category
axioms and these in general do not hold. For example, the only reasonable
candidate for an identity morphism is $\id$ but the expression $\id:A\to A$
is patently not the same expression as $(\id:A\to A)\circ(\id:A\to A)$.

A separate problem is that composition (of expressions) is not
associative. Consider the following expression (written in tree notation):
\begin{equation*}\footnotesize
  \begin{prooftree}
    \hypo{\snd : A \times B \to B}
    \hypo{\fst : (A \times B) \times C \to A \times B}
    \hypo{\fst : ((A \times B) \times C) \times D \to (A \times B) \times C}
    \infer2{\fst\circ\fst : ((A \times B) \times C) \times D \to A \times B}
    \infer2{\snd \circ (\fst\circ\fst) : ((A \times B) \times C) \times D \to B}
    \end{prooftree}.   
\end{equation*}
And here is another way of constructing the same expression:
\begin{equation*}\footnotesize
  \begin{prooftree}
    \hypo{\snd : A \times B \to B}
    \hypo{\fst : (A \times B) \times C \to A \times B}
    \infer2{\snd\circ\fst : (A \times B) \times C \to B}
    \hypo{\fst : ((A \times B) \times C) \times D \to (A \times B) \times C}
    \infer2{(\snd\circ\fst)\circ\fst : ((A \times B) \times C) \times D \to B}
    \end{prooftree}.   
\end{equation*}
On the face of it, these two are not the same construction, hence not the same
expression. 


** Reduction relations

It is clear what to do. We must introduce an equality relation between
constructions that are supposed to be equal and then consider only equivalence
classes. Expressions that are supposed to be equal are as follows, and follow
from the categorical definitions.

The meaning of identity: 
\begin{equation*}
\begin{prooftree}[center=false]
  \hypo{\id : Q \to Q}
  \hypo{e : P \to Q}
  \infer2{\id \circ e : P \to Q}
\end{prooftree}
\;=\;
\begin{prooftree}[center=false]
  \hypo{e : P \to Q}
  \hypo{\id : P \to P}
  \infer2{e \circ \id : P \to Q}
\end{prooftree}
\;=\;
e : P \to Q.
\end{equation*}
Associativity:
\begin{equation*}
\begin{prooftree}[center=false]
  \hypo{e : R \to S}
  \hypo{f : Q \to R}
  \infer2{e \circ f : Q \to S}
  \hypo{g : P \to Q}
  \infer2{(e \circ f) \circ g : P \to S}
\end{prooftree}
  \; = \;
\begin{prooftree}[center=false]
  \hypo{e : R \to S}
  \hypo{f : Q \to R}
  \hypo{g : P \to Q}
  \infer2{f \circ g : P \to R}
  \infer2{e \circ (f \circ g) : P \to S}.
\end{prooftree}
\end{equation*}
The meaning of pairing:
\begin{equation*}
  \begin{prooftree}[center=false]
    \hypo{\fst : X \times Y \to X}
    \hypo{e : P \to X}
    \hypo{f : P \to Y}
    \infer2{\left\langle e, f \right\rangle : P \to X \times Y}
    \infer2{\fst \circ \left\langle e, f\right\rangle : P \to X}
  \end{prooftree}
  \;=\;
  e : P \to X
\end{equation*}
and
\begin{equation*}
  \begin{prooftree}[center=false]
    \hypo{\snd : X \times Y \to Y}
    \hypo{e : P \to X}
    \hypo{f : P \to Y}
    \infer2{\left\langle e, f \right\rangle : P \to X \times Y}
    \infer2{\snd \circ \left\langle e, f\right\rangle : P \to Y}
  \end{prooftree}
  \;=\;
  f : P \to Y.
\end{equation*}
Uniqueness of mediating arrow in pairing (CHECK!):
\begin{equation*}
    \begin{prooftree}[center=false]
      \hypo{\fst : X \times Y \to X}
      \hypo{e : P \to X \times Y}
      \infer2{\fst \circ e : P \to X}
      \hypo{\snd : X \times Y \to Y}
      \hypo{e : P \to X \times Y}
      \infer2{\snd \circ e : P \to Y}
      \infer2{\left\langle \fst \circ e, \snd \circ e\rangle : P \to X \times Y}
    \end{prooftree} 
    =
    e : P \to X \times Y. 
\end{equation*}
Interaction of composition and pairing:
\begin{equation*}
  \begin{prooftree}
    \hypo{e}
    \hypo{g}
    \infer2{e \circ g}
    \hypo{f}
    \hypo{g}
    \infer2{f \circ g}
    \infer2{\left\langle e\circ g, f\circ g \right\rangle}
  \end{prooftree}
  \;=\;
  \begin{prooftree}
    \hypo{e}
    \hypo{f}
    \infer2{\left\langle e, f \right\rangle}
    \hypo{g}
    \infer2{\left\langle e, f \right\rangle \circ g}   
  \end{prooftree}
\end{equation*}
Meaning of the empty product:
\begin{equation*}
\begin{split}
  \fst \circ \unit &= \unit \\
  \snd \circ \unit &= \unit \\
\end{split}
\end{equation*}
Uniqueness of $\unit$:
\begin{equation*}
\begin{split}
  \unit \circ e &= \unit \\
\end{split}
\end{equation*}
Uniqueness of $\top$ (although, actually, maybe we don't want this?)
\begin{equation*}
\begin{split}
  \left\langle \unit, e \right\rangle &= e \\
  \left\langle e, \unit \right\rangle &= e. \\
\end{split}
\end{equation*}

However, we're now in a pickle. To determine whether two terms are equal, we
must find a transformation of one that leads to the other, using the rules
above. But these rules are not deterministic: if we make the wrong choices, we
could end up going round in circles forever.

What is normally done is to /orient/ these equivalences so that they may only be
applied “in one direction.” That takes care of some of the
non-determinism. However, we still have to check (a) that the process will
eventually stop (this is called normalisation) and (b) that two terms that are
equal by the equivalence relation will eventually reduce to the same form (this
is called confluence).

It turns out this is not as easy as I had assumed.

We now introduce a reduction relation on expressions. We shall do this in three
stages. First, we define a reduction relation, $\termstep$, on certain kinds of
expression: it applies “only at the top level.” Then we introduce a reduction
relation, $\step$, by allowing $\termstep$ to act on any subexpression of an
expression. Finally, we take the transitive closure of $\step$ and show that it
has nice properties.

We start with $\termstep$. There are three kinds of expression: /terms/ ($\id$,
$\fst$, and so on); /pairs/ (like $\left\langle e, f \right\rangle$); and
/compositions/ (such as $e\circ f$). The reduction relation $\termstep$ acts on
certain pairs and compositions.  

*** One-step reduction of terms

First, there are the fundamental rules of identity and associativity:
\begin{equation*}
\begin{split}
        \id \circ e &\termstep e \\
        e \circ \id &\termstep e \\
        (e \circ f) \circ g &\termstep e \circ (f \circ g).
\end{split}
\end{equation*}

Second, there are the rules for pairing:
\begin{equation*}
\begin{split}
  \left\langle \fst, \snd \right\rangle &\termstep \id \\ 
  \fst \circ \left\langle e, f\right\rangle &\termstep e \\
  \snd \circ \left\langle e, f\right\rangle &\termstep f \\
  \left\langle e\circ g, f\circ g \right\rangle &\termstep \left\langle e, f \right\rangle \circ g \\ 
\end{split}
\end{equation*}

And finally rules for $\unit$ (which is rather like an empty pair):
\begin{equation*}
  \begin{split}
    \fst \circ \unit &\termstep \unit \\
    \snd \circ \unit &\termstep \unit \\
    \unit \circ e &\termstep \unit \\
    \left\langle \unit, e \right\rangle &\termstep e \\
    \left\langle e, \unit \right\rangle &\termstep e. \\
  \end{split}
\end{equation*}

Note that, with the exception of this last rule, did not need to add the arrow
types because all the types “just work out”. In the last reduction, the type of
$\unit$ has to change.[fn:1] However, there's only one way it can be changed to
make the types compose properly, so we have not bothered to write it in.

*** One-step reduction of expressions

The relation “$\termstep$” acts “at the top-level.” Now define $\step$ as
follows: $e\step f$ if there is some subexpression, $\alpha$ of $e$, and some
reduction $\alpha\termstep\beta$, and $f$ is obtained from $e$ by substituting
$\beta$ for $\alpha$. In other words, we have $e\step f$ if there is any
subexpression in $e$ to which some reduction rule applies and such that, by
applying it, we obtain $f$. 

*** Transitive closure of $\step$

Having reduced $e\step f$, we might, of course, proceed to look for, and apply,
some other reduction, and then another, and continue in this manner until either
we get stuck or we get bored. To capture this notion, we write $e\steps f$ if
there is /any/ finite sequence $e\step e'\step e''\step\dotsb f$. (Note that by
“any” we mean to include the empty sequence, so that, in particular $e\steps e$
for any $e$.)

Now we claim:

1. $\steps$ is a partial ordering on expressions;
2. $\steps$ has the /confluence property/: if $e\steps f$ and $e\steps g$, then
   there exists an $h$ such that $f\steps h$ and $g\steps h$.

To show (1), we must show (i) reflexivity: $e\steps e$; (ii) transitivity: if
$e\steps f$ and $f\steps g$ then $e\steps g$; and (ii) anti-symmetry: if
$e\steps f$ and $f\steps e$ then $e = f$.

Reflexivity and transitivity follow immediately from the definition of $\steps$
as a possible-empty chain of $\step$: the concatenation of the two chains in the
premise is the chain required; and the empty chain relates an expression to
itself. 

To see how we might show (iii), note that each reducible expression has a
“left-hand-side” and a “right-hand-side,” (left and right of the $\circ$
operator, that is) and that each reduction by $\termstep$ seems to make the
left-hand-side “smaller.” If we could capture this idea, reflexivity would
follow, because each reduction would reduce the “size” of the expression, hence
$\step$ would necessarily be “one way only.”

We therefore introduce a comparison of expressions. 

THIS SECTION USES "TERM" FOR ANY OF $\fst$, $\snd$, $\id$, $\unit$, OR
$\left\langle e, e\right\rangle$; AND "COMPEX" FOR $e\circ e$. 

The rules are as follows. First, the “atomic” ones, 
\begin{equation*}
\begin{split}
x &\leqslant x    \qquad\text{for any expression $x$}, \\
\id &\leqslant t  \qquad\text{for any term $t$}, \\
t &\leqslant e    \qquad\text{for any term $t$ and compex $e$}, 
\end{split}
\end{equation*} 

Next, the “derived” ones. For compexes: 
\begin{equation*}
  e_1 \circ e_2 \leqslant f_1 \circ f_2 \quad\text{if and only if}\quad
\begin{cases}
  &\text{either $e_1 = f_1$ and $e_2 \leqslant f_2$,} \\
  &\text{or $e_1 \leqslant f_1$ (and $e_1 \neq f_1$).}
\end{cases}
\end{equation*}

And finally for pairs:
\begin{equation*}
  \left\langle e_1, f_1 \right\rangle \leqslant \left\langle e_2, f_2 \right\rangle 
  \; \text{if and only if} \;
  e_1 \leqslant e_2 \;\text{and}\; f_1 \leqslant f_2.
\end{equation*}






* Footnotes

[fn:1] In the jargon, it is said that $\unit$ is instantiated “at” some other type.

 


